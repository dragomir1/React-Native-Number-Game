// This screen will switch to Game Screen from Start Game Screen when the game is running.  this will have the random num generator logic.

// things that need to happen here..the computer needs to make a guess when the screen loads. and it also needs to make a new guess everytime the user presses 'too high' or 'too low' button.
//do we need component did mount?
// do we need some form of state to hold on to the value the computer guesses?
// the buttons resets the computer and directs them to guess again.

// useRef hook allows to you define and hold to a value that survives component re-renders. in this case when the component rerenders and we get a new num, the previous num is held wih useRef().
import React, { useState, useRef } from 'react';
import { View, Text, StyleSheet, Button, Alert } from 'react-native';

import NumContainer from '../NumberContainer/NumberContainer';
import Card from '../Card/Card';
import Colors from '../../constants/colors';

// creating a new funciton ouside of the GameScreen component. this function shouldn't be recreated every time GameScreen re-renders to save performance.
// if you don't rely on props or state, you can have a function that resides outside of your component.

// excludedNumber is the edge case where it excludes the solution on the first try.  The computer will never guess the number on the first try. if it hits that number it will do a recurcise call to generate a new num.
const generateRandomNum = (min, max, excludeNumber) => {
  min = Math.floor(min);
  max = Math.ceil(max);
  const RandomNumber = Math.floor(Math.random() * (max - min)) + min;

  if (RandomNumber === excludeNumber) {
    return generateRandomNum(min, max, excludeNumber);
  } else {
    return RandomNumber;
  }
};

const GameScreen = props => {
  // we need to manage the state of the random number generated by the computer.  we call the randomNum function and save the resulting value in the currentGuess state.
  // SIDE NOTE: FIRST TIME THIS COMP RENDERS, THE RANDOM NUM WILL BE SAVED AS THE INITIAL STATE.  WHEN COMPONENT RERENDERS AND USESTATE IS CALLED AGAIN, WE GENERATED ANOTHER RANDOM NUMBER, THE NEW STATE WILL NOT OVERRIDE THE INITAL STATE, IT WILL BE MANAGED INDEPENDENTLY BY STATE, DETACHED FROM THE COMPONENT.
  // props.userChoiceNum(excludedNumber) is coming from the StartGameSceen Comp.
  const [currentGuess, setCurrentGuessState] = useState(
    generateRandomNum(1, 100, props.userChoiceNum)
  );
  // these are the initaly values for our randomgen funciton.  we're able to update these references in the nextguesshandler funcion.
  const currentLow = useRef(1);
  const currentHigh = useRef(100);
  // we do this function here because we need access to the sourounding statecomp.
  // we are passing 'direction' as an argument. this denotes which direction the next guess should be..lower or greater.

  // THIS IS IF THE GUESS IS AN INCORRENT VALUE
  const nextGuessHandler = direction => {
    // we need to validate the direction button..if its' 'lower' or 'greater' than the number the compouter guessed.
    // this piece of logic just throw p an alert if it incorrent guess.
    if (
      (direction === 'lower' && currentGuess < props.userChoiceNum) ||
      (direction === 'higher' && currentGuess > props.userChoiceNum)
    ) {
      Alert.alert("Don't lie", "You know it's wrong", [
        { text: 'Okie Dokie', style: 'cancel' }
      ]);
      return;
    }
    // this logic checks hold the updated values as the current high & low. if computer guesses too high or too low. then useRef() holds that new number as the current reference value.
    if (direction === 'lower') {
      // here we the current mim and max should adjust over time as hints are given if the computer guess too small or too big.  for that we use a hook..the useRef() hook.

      // current is a property on the references generated by react are object with a current property where the value is stored in.
      // here we are setting the currentHigh to the new current guess.
      currentHigh.current = currentGuess;
    } else {
      currentLow.current = currentGuess;
    }
    // here we generate a new random number with new high and low references and set that as the new currently guessed number.
    const nextNumber = generateRandomNum(
      currentLow.current,
      currentHigh.current,
      currentGuess
    );
    setCurrentGuessState(nextNumber);
  };

  return (
    <View style={styles.screen}>
      <Text>The Computer's Guess:</Text>
      <NumContainer>{currentGuess}</NumContainer>
      <Card style={styles.buttonStyling}>
        <View>
          <Button
            title='LOWER'
            color={Colors.startGameColor}
            /* the value we have here passed as an argument should differ based on the button.  need to preconfigure the argument that's passed to the handler when it's executed.  we use the bind method for preconfiguration.*/
            // "this" is the first argument to bind. its what's should be referred to in the function thats getting called.
            // 'lower' is the first agrument recieved by the handler
            onPress={nextGuessHandler.bind(this, 'lower')}
          />
        </View>
        <View>
          <Button
            title='HIGHER'
            color={Colors.startGameColor}
            onPress={nextGuessHandler.bind(this, 'higher')}
          />
        </View>
      </Card>
    </View>
  );
};

const styles = StyleSheet.create({
  screen: {
    // this will take all the avail screen below the header.  this is the child component of the App.
    flex: 1,
    padding: 10,
    alignItems: 'center'
  },
  buttonStyling: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginTop: 20,
    width: 300,
    // this will not exceed the boundires of the parent view.
    maxWidth: '80%'
  }
});

export default GameScreen;
